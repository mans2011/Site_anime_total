"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/anime/[id]/page",{

/***/ "(app-pages-browser)/./lib/userStorage.ts":
/*!****************************!*\
  !*** ./lib/userStorage.ts ***!
  \****************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   userStorage: () => (/* binding */ userStorage)\n/* harmony export */ });\n/* harmony import */ var _lib_supabaseClient__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/lib/supabaseClient */ \"(app-pages-browser)/./lib/supabaseClient.ts\");\n\nconst STORAGE_KEYS = {\n    CURRENT_USER: 'animeflix_current_user'\n};\n// ----- SUPABASE -----\nasync function fetchUserFromSupabase(userId) {\n    const { data, error } = await _lib_supabaseClient__WEBPACK_IMPORTED_MODULE_0__.supabase.from('profiles').select('id, full_name, email, avatar, watchlist, favorites, watchHistory, ratings').eq('id', userId).single();\n    if (error || !data) return null;\n    return {\n        id: data.id,\n        name: data.full_name || '',\n        email: data.email || '',\n        avatar: data.avatar || '',\n        watchlist: data.watchlist || [],\n        favorites: data.favorites || [],\n        watchHistory: data.watchHistory || [],\n        ratings: data.ratings || []\n    };\n}\nasync function updateUserOnSupabase(user) {\n    const { error } = await _lib_supabaseClient__WEBPACK_IMPORTED_MODULE_0__.supabase.from('profiles').upsert({\n        id: user.id,\n        full_name: user.name,\n        email: user.email,\n        avatar: user.avatar || null,\n        watchlist: user.watchlist,\n        favorites: user.favorites,\n        watchHistory: user.watchHistory,\n        ratings: user.ratings,\n        updated_at: new Date().toISOString()\n    });\n    if (error) console.error('Erro ao atualizar usuÃ¡rio no Supabase:', error);\n}\n// ----- STORAGE -----\nconst userStorage = {\n    getCurrentUser () {\n        if (false) {}\n        const userData = localStorage.getItem(STORAGE_KEYS.CURRENT_USER);\n        return userData ? JSON.parse(userData) : null;\n    },\n    async setCurrentUser (user) {\n        if (false) {}\n        if (user) {\n            localStorage.setItem(STORAGE_KEYS.CURRENT_USER, JSON.stringify(user));\n            await updateUserOnSupabase(user);\n        } else {\n            localStorage.removeItem(STORAGE_KEYS.CURRENT_USER);\n        }\n    },\n    async syncWithSupabase () {\n        const { data } = await _lib_supabaseClient__WEBPACK_IMPORTED_MODULE_0__.supabase.auth.getUser();\n        const authUser = data === null || data === void 0 ? void 0 : data.user;\n        if (!authUser) return;\n        const supabaseUser = await fetchUserFromSupabase(authUser.id);\n        if (!supabaseUser) return;\n        const localUser = this.getCurrentUser();\n        if (!localUser || JSON.stringify(localUser) !== JSON.stringify(supabaseUser)) {\n            localStorage.setItem(STORAGE_KEYS.CURRENT_USER, JSON.stringify(supabaseUser));\n        }\n    },\n    async addToWatchlist (animeId) {\n        const user = this.getCurrentUser();\n        if (!user) return;\n        if (!user.watchlist.includes(animeId)) {\n            user.watchlist.push(animeId);\n            await this.setCurrentUser(user);\n        }\n    },\n    async removeFromWatchlist (animeId) {\n        const user = this.getCurrentUser();\n        if (!user) return;\n        user.watchlist = user.watchlist.filter((id)=>id !== animeId);\n        await this.setCurrentUser(user);\n    },\n    async addToFavorites (animeId) {\n        const user = this.getCurrentUser();\n        if (!user) return;\n        if (!user.favorites.includes(animeId)) {\n            user.favorites.push(animeId);\n            await this.setCurrentUser(user);\n        }\n    },\n    async removeFromFavorites (animeId) {\n        const user = this.getCurrentUser();\n        if (!user) return;\n        user.favorites = user.favorites.filter((id)=>id !== animeId);\n        await this.setCurrentUser(user);\n    },\n    async addToWatchHistory (animeId, episodeNumber) {\n        const user = this.getCurrentUser();\n        if (!user) return;\n        const existingIndex = user.watchHistory.findIndex((h)=>h.animeId === animeId);\n        const historyEntry = {\n            animeId,\n            watchedAt: new Date().toISOString(),\n            episodeNumber\n        };\n        if (existingIndex >= 0) {\n            user.watchHistory[existingIndex] = historyEntry;\n        } else {\n            user.watchHistory.unshift(historyEntry);\n        }\n        if (user.watchHistory.length > 100) {\n            user.watchHistory = user.watchHistory.slice(0, 100);\n        }\n        await this.setCurrentUser(user);\n    },\n    async rateAnime (animeId, rating) {\n        const user = this.getCurrentUser();\n        if (!user) return;\n        const existingIndex = user.ratings.findIndex((r)=>r.animeId === animeId);\n        const ratingEntry = {\n            animeId,\n            rating,\n            ratedAt: new Date().toISOString()\n        };\n        if (existingIndex >= 0) {\n            user.ratings[existingIndex] = ratingEntry;\n        } else {\n            user.ratings.push(ratingEntry);\n        }\n        await this.setCurrentUser(user);\n    },\n    getUserRating (animeId) {\n        const user = this.getCurrentUser();\n        if (!user) return null;\n        const rating = user.ratings.find((r)=>r.animeId === animeId);\n        return rating ? rating.rating : null;\n    },\n    findUserByEmail (email) {\n        const user = this.getCurrentUser();\n        if ((user === null || user === void 0 ? void 0 : user.email) === email) return user;\n        return null;\n    }\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2xpYi91c2VyU3RvcmFnZS50cyIsIm1hcHBpbmdzIjoiOzs7OztBQUFnRDtBQXFCaEQsTUFBTUMsZUFBZTtJQUNuQkMsY0FBYztBQUNoQjtBQUVBLHVCQUF1QjtBQUN2QixlQUFlQyxzQkFBc0JDLE1BQWM7SUFDakQsTUFBTSxFQUFFQyxJQUFJLEVBQUVDLEtBQUssRUFBRSxHQUFHLE1BQU1OLHlEQUFRQSxDQUNuQ08sSUFBSSxDQUFDLFlBQ0xDLE1BQU0sQ0FBQyw2RUFDUEMsRUFBRSxDQUFDLE1BQU1MLFFBQ1RNLE1BQU07SUFFVCxJQUFJSixTQUFTLENBQUNELE1BQU0sT0FBTztJQUUzQixPQUFPO1FBQ0xNLElBQUlOLEtBQUtNLEVBQUU7UUFDWEMsTUFBTVAsS0FBS1EsU0FBUyxJQUFJO1FBQ3hCQyxPQUFPVCxLQUFLUyxLQUFLLElBQUk7UUFDckJDLFFBQVFWLEtBQUtVLE1BQU0sSUFBSTtRQUN2QkMsV0FBV1gsS0FBS1csU0FBUyxJQUFJLEVBQUU7UUFDL0JDLFdBQVdaLEtBQUtZLFNBQVMsSUFBSSxFQUFFO1FBQy9CQyxjQUFjYixLQUFLYSxZQUFZLElBQUksRUFBRTtRQUNyQ0MsU0FBU2QsS0FBS2MsT0FBTyxJQUFJLEVBQUU7SUFDN0I7QUFDRjtBQUVBLGVBQWVDLHFCQUFxQkMsSUFBVTtJQUM1QyxNQUFNLEVBQUVmLEtBQUssRUFBRSxHQUFHLE1BQU1OLHlEQUFRQSxDQUFDTyxJQUFJLENBQUMsWUFBWWUsTUFBTSxDQUFDO1FBQ3ZEWCxJQUFJVSxLQUFLVixFQUFFO1FBQ1hFLFdBQVdRLEtBQUtULElBQUk7UUFDcEJFLE9BQU9PLEtBQUtQLEtBQUs7UUFDakJDLFFBQVFNLEtBQUtOLE1BQU0sSUFBSTtRQUN2QkMsV0FBV0ssS0FBS0wsU0FBUztRQUN6QkMsV0FBV0ksS0FBS0osU0FBUztRQUN6QkMsY0FBY0csS0FBS0gsWUFBWTtRQUMvQkMsU0FBU0UsS0FBS0YsT0FBTztRQUNyQkksWUFBWSxJQUFJQyxPQUFPQyxXQUFXO0lBQ3BDO0lBQ0EsSUFBSW5CLE9BQU9vQixRQUFRcEIsS0FBSyxDQUFDLDBDQUEwQ0E7QUFDckU7QUFFQSxzQkFBc0I7QUFDZixNQUFNcUIsY0FBYztJQUN6QkM7UUFDRSxJQUFJLEtBQTZCLEVBQUUsRUFBWTtRQUMvQyxNQUFNQyxXQUFXQyxhQUFhQyxPQUFPLENBQUM5QixhQUFhQyxZQUFZO1FBQy9ELE9BQU8yQixXQUFXRyxLQUFLQyxLQUFLLENBQUNKLFlBQVk7SUFDM0M7SUFFQSxNQUFNSyxnQkFBZWIsSUFBaUI7UUFDcEMsSUFBSSxLQUE2QixFQUFFLEVBQU87UUFDMUMsSUFBSUEsTUFBTTtZQUNSUyxhQUFhSyxPQUFPLENBQUNsQyxhQUFhQyxZQUFZLEVBQUU4QixLQUFLSSxTQUFTLENBQUNmO1lBQy9ELE1BQU1ELHFCQUFxQkM7UUFDN0IsT0FBTztZQUNMUyxhQUFhTyxVQUFVLENBQUNwQyxhQUFhQyxZQUFZO1FBQ25EO0lBQ0Y7SUFFQSxNQUFNb0M7UUFDSixNQUFNLEVBQUVqQyxJQUFJLEVBQUUsR0FBRyxNQUFNTCx5REFBUUEsQ0FBQ3VDLElBQUksQ0FBQ0MsT0FBTztRQUM1QyxNQUFNQyxXQUFXcEMsaUJBQUFBLDJCQUFBQSxLQUFNZ0IsSUFBSTtRQUMzQixJQUFJLENBQUNvQixVQUFVO1FBRWYsTUFBTUMsZUFBZSxNQUFNdkMsc0JBQXNCc0MsU0FBUzlCLEVBQUU7UUFDNUQsSUFBSSxDQUFDK0IsY0FBYztRQUVuQixNQUFNQyxZQUFZLElBQUksQ0FBQ2YsY0FBYztRQUNyQyxJQUFJLENBQUNlLGFBQWFYLEtBQUtJLFNBQVMsQ0FBQ08sZUFBZVgsS0FBS0ksU0FBUyxDQUFDTSxlQUFlO1lBQzVFWixhQUFhSyxPQUFPLENBQUNsQyxhQUFhQyxZQUFZLEVBQUU4QixLQUFLSSxTQUFTLENBQUNNO1FBQ2pFO0lBQ0Y7SUFFQSxNQUFNRSxnQkFBZUMsT0FBZTtRQUNsQyxNQUFNeEIsT0FBTyxJQUFJLENBQUNPLGNBQWM7UUFDaEMsSUFBSSxDQUFDUCxNQUFNO1FBQ1gsSUFBSSxDQUFDQSxLQUFLTCxTQUFTLENBQUM4QixRQUFRLENBQUNELFVBQVU7WUFDckN4QixLQUFLTCxTQUFTLENBQUMrQixJQUFJLENBQUNGO1lBQ3BCLE1BQU0sSUFBSSxDQUFDWCxjQUFjLENBQUNiO1FBQzVCO0lBQ0Y7SUFFQSxNQUFNMkIscUJBQW9CSCxPQUFlO1FBQ3ZDLE1BQU14QixPQUFPLElBQUksQ0FBQ08sY0FBYztRQUNoQyxJQUFJLENBQUNQLE1BQU07UUFDWEEsS0FBS0wsU0FBUyxHQUFHSyxLQUFLTCxTQUFTLENBQUNpQyxNQUFNLENBQUN0QyxDQUFBQSxLQUFNQSxPQUFPa0M7UUFDcEQsTUFBTSxJQUFJLENBQUNYLGNBQWMsQ0FBQ2I7SUFDNUI7SUFFQSxNQUFNNkIsZ0JBQWVMLE9BQWU7UUFDbEMsTUFBTXhCLE9BQU8sSUFBSSxDQUFDTyxjQUFjO1FBQ2hDLElBQUksQ0FBQ1AsTUFBTTtRQUNYLElBQUksQ0FBQ0EsS0FBS0osU0FBUyxDQUFDNkIsUUFBUSxDQUFDRCxVQUFVO1lBQ3JDeEIsS0FBS0osU0FBUyxDQUFDOEIsSUFBSSxDQUFDRjtZQUNwQixNQUFNLElBQUksQ0FBQ1gsY0FBYyxDQUFDYjtRQUM1QjtJQUNGO0lBRUEsTUFBTThCLHFCQUFvQk4sT0FBZTtRQUN2QyxNQUFNeEIsT0FBTyxJQUFJLENBQUNPLGNBQWM7UUFDaEMsSUFBSSxDQUFDUCxNQUFNO1FBQ1hBLEtBQUtKLFNBQVMsR0FBR0ksS0FBS0osU0FBUyxDQUFDZ0MsTUFBTSxDQUFDdEMsQ0FBQUEsS0FBTUEsT0FBT2tDO1FBQ3BELE1BQU0sSUFBSSxDQUFDWCxjQUFjLENBQUNiO0lBQzVCO0lBRUEsTUFBTStCLG1CQUFrQlAsT0FBZSxFQUFFUSxhQUFzQjtRQUM3RCxNQUFNaEMsT0FBTyxJQUFJLENBQUNPLGNBQWM7UUFDaEMsSUFBSSxDQUFDUCxNQUFNO1FBRVgsTUFBTWlDLGdCQUFnQmpDLEtBQUtILFlBQVksQ0FBQ3FDLFNBQVMsQ0FBQ0MsQ0FBQUEsSUFBS0EsRUFBRVgsT0FBTyxLQUFLQTtRQUNyRSxNQUFNWSxlQUFlO1lBQ25CWjtZQUNBYSxXQUFXLElBQUlsQyxPQUFPQyxXQUFXO1lBQ2pDNEI7UUFDRjtRQUVBLElBQUlDLGlCQUFpQixHQUFHO1lBQ3RCakMsS0FBS0gsWUFBWSxDQUFDb0MsY0FBYyxHQUFHRztRQUNyQyxPQUFPO1lBQ0xwQyxLQUFLSCxZQUFZLENBQUN5QyxPQUFPLENBQUNGO1FBQzVCO1FBRUEsSUFBSXBDLEtBQUtILFlBQVksQ0FBQzBDLE1BQU0sR0FBRyxLQUFLO1lBQ2xDdkMsS0FBS0gsWUFBWSxHQUFHRyxLQUFLSCxZQUFZLENBQUMyQyxLQUFLLENBQUMsR0FBRztRQUNqRDtRQUNBLE1BQU0sSUFBSSxDQUFDM0IsY0FBYyxDQUFDYjtJQUM1QjtJQUVBLE1BQU15QyxXQUFVakIsT0FBZSxFQUFFa0IsTUFBYztRQUM3QyxNQUFNMUMsT0FBTyxJQUFJLENBQUNPLGNBQWM7UUFDaEMsSUFBSSxDQUFDUCxNQUFNO1FBRVgsTUFBTWlDLGdCQUFnQmpDLEtBQUtGLE9BQU8sQ0FBQ29DLFNBQVMsQ0FBQ1MsQ0FBQUEsSUFBS0EsRUFBRW5CLE9BQU8sS0FBS0E7UUFDaEUsTUFBTW9CLGNBQWM7WUFDbEJwQjtZQUNBa0I7WUFDQUcsU0FBUyxJQUFJMUMsT0FBT0MsV0FBVztRQUNqQztRQUVBLElBQUk2QixpQkFBaUIsR0FBRztZQUN0QmpDLEtBQUtGLE9BQU8sQ0FBQ21DLGNBQWMsR0FBR1c7UUFDaEMsT0FBTztZQUNMNUMsS0FBS0YsT0FBTyxDQUFDNEIsSUFBSSxDQUFDa0I7UUFDcEI7UUFDQSxNQUFNLElBQUksQ0FBQy9CLGNBQWMsQ0FBQ2I7SUFDNUI7SUFFQThDLGVBQWN0QixPQUFlO1FBQzNCLE1BQU14QixPQUFPLElBQUksQ0FBQ08sY0FBYztRQUNoQyxJQUFJLENBQUNQLE1BQU0sT0FBTztRQUVsQixNQUFNMEMsU0FBUzFDLEtBQUtGLE9BQU8sQ0FBQ2lELElBQUksQ0FBQ0osQ0FBQUEsSUFBS0EsRUFBRW5CLE9BQU8sS0FBS0E7UUFDcEQsT0FBT2tCLFNBQVNBLE9BQU9BLE1BQU0sR0FBRztJQUNsQztJQUVBTSxpQkFBZ0J2RCxLQUFhO1FBQzNCLE1BQU1PLE9BQU8sSUFBSSxDQUFDTyxjQUFjO1FBQ2hDLElBQUlQLENBQUFBLGlCQUFBQSwyQkFBQUEsS0FBTVAsS0FBSyxNQUFLQSxPQUFPLE9BQU9PO1FBQ2xDLE9BQU87SUFDVDtBQUNGLEVBQUUiLCJzb3VyY2VzIjpbIkQ6XFxwcm9qZWN0c1xcY29kZXNcXGN1cnNvXFxwcm9qZXRvLWFuaW1lLXBybzJcXGxpYlxcdXNlclN0b3JhZ2UudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgc3VwYWJhc2UgfSBmcm9tICdAL2xpYi9zdXBhYmFzZUNsaWVudCc7XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFVzZXIge1xyXG4gIGlkOiBzdHJpbmc7XHJcbiAgbmFtZTogc3RyaW5nO1xyXG4gIGVtYWlsOiBzdHJpbmc7XHJcbiAgYXZhdGFyPzogc3RyaW5nO1xyXG4gIHdhdGNobGlzdDogbnVtYmVyW107XHJcbiAgZmF2b3JpdGVzOiBudW1iZXJbXTtcclxuICB3YXRjaEhpc3Rvcnk6IEFycmF5PHtcclxuICAgIGFuaW1lSWQ6IG51bWJlcjtcclxuICAgIHdhdGNoZWRBdDogc3RyaW5nO1xyXG4gICAgZXBpc29kZU51bWJlcj86IG51bWJlcjtcclxuICB9PjtcclxuICByYXRpbmdzOiBBcnJheTx7XHJcbiAgICBhbmltZUlkOiBudW1iZXI7XHJcbiAgICByYXRpbmc6IG51bWJlcjtcclxuICAgIHJhdGVkQXQ6IHN0cmluZztcclxuICB9PjtcclxufVxyXG5cclxuY29uc3QgU1RPUkFHRV9LRVlTID0ge1xyXG4gIENVUlJFTlRfVVNFUjogJ2FuaW1lZmxpeF9jdXJyZW50X3VzZXInXHJcbn07XHJcblxyXG4vLyAtLS0tLSBTVVBBQkFTRSAtLS0tLVxyXG5hc3luYyBmdW5jdGlvbiBmZXRjaFVzZXJGcm9tU3VwYWJhc2UodXNlcklkOiBzdHJpbmcpOiBQcm9taXNlPFVzZXIgfCBudWxsPiB7XHJcbiAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcclxuICAgIC5mcm9tKCdwcm9maWxlcycpXHJcbiAgICAuc2VsZWN0KCdpZCwgZnVsbF9uYW1lLCBlbWFpbCwgYXZhdGFyLCB3YXRjaGxpc3QsIGZhdm9yaXRlcywgd2F0Y2hIaXN0b3J5LCByYXRpbmdzJylcclxuICAgIC5lcSgnaWQnLCB1c2VySWQpXHJcbiAgICAuc2luZ2xlKCk7XHJcblxyXG4gIGlmIChlcnJvciB8fCAhZGF0YSkgcmV0dXJuIG51bGw7XHJcblxyXG4gIHJldHVybiB7XHJcbiAgICBpZDogZGF0YS5pZCxcclxuICAgIG5hbWU6IGRhdGEuZnVsbF9uYW1lIHx8ICcnLFxyXG4gICAgZW1haWw6IGRhdGEuZW1haWwgfHwgJycsXHJcbiAgICBhdmF0YXI6IGRhdGEuYXZhdGFyIHx8ICcnLFxyXG4gICAgd2F0Y2hsaXN0OiBkYXRhLndhdGNobGlzdCB8fCBbXSxcclxuICAgIGZhdm9yaXRlczogZGF0YS5mYXZvcml0ZXMgfHwgW10sXHJcbiAgICB3YXRjaEhpc3Rvcnk6IGRhdGEud2F0Y2hIaXN0b3J5IHx8IFtdLFxyXG4gICAgcmF0aW5nczogZGF0YS5yYXRpbmdzIHx8IFtdXHJcbiAgfTtcclxufVxyXG5cclxuYXN5bmMgZnVuY3Rpb24gdXBkYXRlVXNlck9uU3VwYWJhc2UodXNlcjogVXNlcikge1xyXG4gIGNvbnN0IHsgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlLmZyb20oJ3Byb2ZpbGVzJykudXBzZXJ0KHtcclxuICAgIGlkOiB1c2VyLmlkLFxyXG4gICAgZnVsbF9uYW1lOiB1c2VyLm5hbWUsXHJcbiAgICBlbWFpbDogdXNlci5lbWFpbCxcclxuICAgIGF2YXRhcjogdXNlci5hdmF0YXIgfHwgbnVsbCxcclxuICAgIHdhdGNobGlzdDogdXNlci53YXRjaGxpc3QsXHJcbiAgICBmYXZvcml0ZXM6IHVzZXIuZmF2b3JpdGVzLFxyXG4gICAgd2F0Y2hIaXN0b3J5OiB1c2VyLndhdGNoSGlzdG9yeSxcclxuICAgIHJhdGluZ3M6IHVzZXIucmF0aW5ncyxcclxuICAgIHVwZGF0ZWRfYXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKVxyXG4gIH0pO1xyXG4gIGlmIChlcnJvcikgY29uc29sZS5lcnJvcignRXJybyBhbyBhdHVhbGl6YXIgdXN1w6FyaW8gbm8gU3VwYWJhc2U6JywgZXJyb3IpO1xyXG59XHJcblxyXG4vLyAtLS0tLSBTVE9SQUdFIC0tLS0tXHJcbmV4cG9ydCBjb25zdCB1c2VyU3RvcmFnZSA9IHtcclxuICBnZXRDdXJyZW50VXNlcigpOiBVc2VyIHwgbnVsbCB7XHJcbiAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHJldHVybiBudWxsO1xyXG4gICAgY29uc3QgdXNlckRhdGEgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShTVE9SQUdFX0tFWVMuQ1VSUkVOVF9VU0VSKTtcclxuICAgIHJldHVybiB1c2VyRGF0YSA/IEpTT04ucGFyc2UodXNlckRhdGEpIDogbnVsbDtcclxuICB9LFxyXG5cclxuICBhc3luYyBzZXRDdXJyZW50VXNlcih1c2VyOiBVc2VyIHwgbnVsbCkge1xyXG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSByZXR1cm47XHJcbiAgICBpZiAodXNlcikge1xyXG4gICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShTVE9SQUdFX0tFWVMuQ1VSUkVOVF9VU0VSLCBKU09OLnN0cmluZ2lmeSh1c2VyKSk7XHJcbiAgICAgIGF3YWl0IHVwZGF0ZVVzZXJPblN1cGFiYXNlKHVzZXIpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oU1RPUkFHRV9LRVlTLkNVUlJFTlRfVVNFUik7XHJcbiAgICB9XHJcbiAgfSxcclxuXHJcbiAgYXN5bmMgc3luY1dpdGhTdXBhYmFzZSgpIHtcclxuICAgIGNvbnN0IHsgZGF0YSB9ID0gYXdhaXQgc3VwYWJhc2UuYXV0aC5nZXRVc2VyKCk7XHJcbiAgICBjb25zdCBhdXRoVXNlciA9IGRhdGE/LnVzZXI7XHJcbiAgICBpZiAoIWF1dGhVc2VyKSByZXR1cm47XHJcblxyXG4gICAgY29uc3Qgc3VwYWJhc2VVc2VyID0gYXdhaXQgZmV0Y2hVc2VyRnJvbVN1cGFiYXNlKGF1dGhVc2VyLmlkKTtcclxuICAgIGlmICghc3VwYWJhc2VVc2VyKSByZXR1cm47XHJcblxyXG4gICAgY29uc3QgbG9jYWxVc2VyID0gdGhpcy5nZXRDdXJyZW50VXNlcigpO1xyXG4gICAgaWYgKCFsb2NhbFVzZXIgfHwgSlNPTi5zdHJpbmdpZnkobG9jYWxVc2VyKSAhPT0gSlNPTi5zdHJpbmdpZnkoc3VwYWJhc2VVc2VyKSkge1xyXG4gICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShTVE9SQUdFX0tFWVMuQ1VSUkVOVF9VU0VSLCBKU09OLnN0cmluZ2lmeShzdXBhYmFzZVVzZXIpKTtcclxuICAgIH1cclxuICB9LFxyXG5cclxuICBhc3luYyBhZGRUb1dhdGNobGlzdChhbmltZUlkOiBudW1iZXIpIHtcclxuICAgIGNvbnN0IHVzZXIgPSB0aGlzLmdldEN1cnJlbnRVc2VyKCk7XHJcbiAgICBpZiAoIXVzZXIpIHJldHVybjtcclxuICAgIGlmICghdXNlci53YXRjaGxpc3QuaW5jbHVkZXMoYW5pbWVJZCkpIHtcclxuICAgICAgdXNlci53YXRjaGxpc3QucHVzaChhbmltZUlkKTtcclxuICAgICAgYXdhaXQgdGhpcy5zZXRDdXJyZW50VXNlcih1c2VyKTtcclxuICAgIH1cclxuICB9LFxyXG5cclxuICBhc3luYyByZW1vdmVGcm9tV2F0Y2hsaXN0KGFuaW1lSWQ6IG51bWJlcikge1xyXG4gICAgY29uc3QgdXNlciA9IHRoaXMuZ2V0Q3VycmVudFVzZXIoKTtcclxuICAgIGlmICghdXNlcikgcmV0dXJuO1xyXG4gICAgdXNlci53YXRjaGxpc3QgPSB1c2VyLndhdGNobGlzdC5maWx0ZXIoaWQgPT4gaWQgIT09IGFuaW1lSWQpO1xyXG4gICAgYXdhaXQgdGhpcy5zZXRDdXJyZW50VXNlcih1c2VyKTtcclxuICB9LFxyXG5cclxuICBhc3luYyBhZGRUb0Zhdm9yaXRlcyhhbmltZUlkOiBudW1iZXIpIHtcclxuICAgIGNvbnN0IHVzZXIgPSB0aGlzLmdldEN1cnJlbnRVc2VyKCk7XHJcbiAgICBpZiAoIXVzZXIpIHJldHVybjtcclxuICAgIGlmICghdXNlci5mYXZvcml0ZXMuaW5jbHVkZXMoYW5pbWVJZCkpIHtcclxuICAgICAgdXNlci5mYXZvcml0ZXMucHVzaChhbmltZUlkKTtcclxuICAgICAgYXdhaXQgdGhpcy5zZXRDdXJyZW50VXNlcih1c2VyKTtcclxuICAgIH1cclxuICB9LFxyXG5cclxuICBhc3luYyByZW1vdmVGcm9tRmF2b3JpdGVzKGFuaW1lSWQ6IG51bWJlcikge1xyXG4gICAgY29uc3QgdXNlciA9IHRoaXMuZ2V0Q3VycmVudFVzZXIoKTtcclxuICAgIGlmICghdXNlcikgcmV0dXJuO1xyXG4gICAgdXNlci5mYXZvcml0ZXMgPSB1c2VyLmZhdm9yaXRlcy5maWx0ZXIoaWQgPT4gaWQgIT09IGFuaW1lSWQpO1xyXG4gICAgYXdhaXQgdGhpcy5zZXRDdXJyZW50VXNlcih1c2VyKTtcclxuICB9LFxyXG5cclxuICBhc3luYyBhZGRUb1dhdGNoSGlzdG9yeShhbmltZUlkOiBudW1iZXIsIGVwaXNvZGVOdW1iZXI/OiBudW1iZXIpIHtcclxuICAgIGNvbnN0IHVzZXIgPSB0aGlzLmdldEN1cnJlbnRVc2VyKCk7XHJcbiAgICBpZiAoIXVzZXIpIHJldHVybjtcclxuXHJcbiAgICBjb25zdCBleGlzdGluZ0luZGV4ID0gdXNlci53YXRjaEhpc3RvcnkuZmluZEluZGV4KGggPT4gaC5hbmltZUlkID09PSBhbmltZUlkKTtcclxuICAgIGNvbnN0IGhpc3RvcnlFbnRyeSA9IHtcclxuICAgICAgYW5pbWVJZCxcclxuICAgICAgd2F0Y2hlZEF0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXHJcbiAgICAgIGVwaXNvZGVOdW1iZXJcclxuICAgIH07XHJcblxyXG4gICAgaWYgKGV4aXN0aW5nSW5kZXggPj0gMCkge1xyXG4gICAgICB1c2VyLndhdGNoSGlzdG9yeVtleGlzdGluZ0luZGV4XSA9IGhpc3RvcnlFbnRyeTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHVzZXIud2F0Y2hIaXN0b3J5LnVuc2hpZnQoaGlzdG9yeUVudHJ5KTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAodXNlci53YXRjaEhpc3RvcnkubGVuZ3RoID4gMTAwKSB7XHJcbiAgICAgIHVzZXIud2F0Y2hIaXN0b3J5ID0gdXNlci53YXRjaEhpc3Rvcnkuc2xpY2UoMCwgMTAwKTtcclxuICAgIH1cclxuICAgIGF3YWl0IHRoaXMuc2V0Q3VycmVudFVzZXIodXNlcik7XHJcbiAgfSxcclxuXHJcbiAgYXN5bmMgcmF0ZUFuaW1lKGFuaW1lSWQ6IG51bWJlciwgcmF0aW5nOiBudW1iZXIpIHtcclxuICAgIGNvbnN0IHVzZXIgPSB0aGlzLmdldEN1cnJlbnRVc2VyKCk7XHJcbiAgICBpZiAoIXVzZXIpIHJldHVybjtcclxuXHJcbiAgICBjb25zdCBleGlzdGluZ0luZGV4ID0gdXNlci5yYXRpbmdzLmZpbmRJbmRleChyID0+IHIuYW5pbWVJZCA9PT0gYW5pbWVJZCk7XHJcbiAgICBjb25zdCByYXRpbmdFbnRyeSA9IHtcclxuICAgICAgYW5pbWVJZCxcclxuICAgICAgcmF0aW5nLFxyXG4gICAgICByYXRlZEF0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKClcclxuICAgIH07XHJcblxyXG4gICAgaWYgKGV4aXN0aW5nSW5kZXggPj0gMCkge1xyXG4gICAgICB1c2VyLnJhdGluZ3NbZXhpc3RpbmdJbmRleF0gPSByYXRpbmdFbnRyeTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHVzZXIucmF0aW5ncy5wdXNoKHJhdGluZ0VudHJ5KTtcclxuICAgIH1cclxuICAgIGF3YWl0IHRoaXMuc2V0Q3VycmVudFVzZXIodXNlcik7XHJcbiAgfSxcclxuXHJcbiAgZ2V0VXNlclJhdGluZyhhbmltZUlkOiBudW1iZXIpOiBudW1iZXIgfCBudWxsIHtcclxuICAgIGNvbnN0IHVzZXIgPSB0aGlzLmdldEN1cnJlbnRVc2VyKCk7XHJcbiAgICBpZiAoIXVzZXIpIHJldHVybiBudWxsO1xyXG5cclxuICAgIGNvbnN0IHJhdGluZyA9IHVzZXIucmF0aW5ncy5maW5kKHIgPT4gci5hbmltZUlkID09PSBhbmltZUlkKTtcclxuICAgIHJldHVybiByYXRpbmcgPyByYXRpbmcucmF0aW5nIDogbnVsbDtcclxuICB9LFxyXG5cclxuICBmaW5kVXNlckJ5RW1haWwoZW1haWw6IHN0cmluZyk6IFVzZXIgfCBudWxsIHtcclxuICAgIGNvbnN0IHVzZXIgPSB0aGlzLmdldEN1cnJlbnRVc2VyKCk7XHJcbiAgICBpZiAodXNlcj8uZW1haWwgPT09IGVtYWlsKSByZXR1cm4gdXNlcjtcclxuICAgIHJldHVybiBudWxsO1xyXG4gIH1cclxufTtcclxuIl0sIm5hbWVzIjpbInN1cGFiYXNlIiwiU1RPUkFHRV9LRVlTIiwiQ1VSUkVOVF9VU0VSIiwiZmV0Y2hVc2VyRnJvbVN1cGFiYXNlIiwidXNlcklkIiwiZGF0YSIsImVycm9yIiwiZnJvbSIsInNlbGVjdCIsImVxIiwic2luZ2xlIiwiaWQiLCJuYW1lIiwiZnVsbF9uYW1lIiwiZW1haWwiLCJhdmF0YXIiLCJ3YXRjaGxpc3QiLCJmYXZvcml0ZXMiLCJ3YXRjaEhpc3RvcnkiLCJyYXRpbmdzIiwidXBkYXRlVXNlck9uU3VwYWJhc2UiLCJ1c2VyIiwidXBzZXJ0IiwidXBkYXRlZF9hdCIsIkRhdGUiLCJ0b0lTT1N0cmluZyIsImNvbnNvbGUiLCJ1c2VyU3RvcmFnZSIsImdldEN1cnJlbnRVc2VyIiwidXNlckRhdGEiLCJsb2NhbFN0b3JhZ2UiLCJnZXRJdGVtIiwiSlNPTiIsInBhcnNlIiwic2V0Q3VycmVudFVzZXIiLCJzZXRJdGVtIiwic3RyaW5naWZ5IiwicmVtb3ZlSXRlbSIsInN5bmNXaXRoU3VwYWJhc2UiLCJhdXRoIiwiZ2V0VXNlciIsImF1dGhVc2VyIiwic3VwYWJhc2VVc2VyIiwibG9jYWxVc2VyIiwiYWRkVG9XYXRjaGxpc3QiLCJhbmltZUlkIiwiaW5jbHVkZXMiLCJwdXNoIiwicmVtb3ZlRnJvbVdhdGNobGlzdCIsImZpbHRlciIsImFkZFRvRmF2b3JpdGVzIiwicmVtb3ZlRnJvbUZhdm9yaXRlcyIsImFkZFRvV2F0Y2hIaXN0b3J5IiwiZXBpc29kZU51bWJlciIsImV4aXN0aW5nSW5kZXgiLCJmaW5kSW5kZXgiLCJoIiwiaGlzdG9yeUVudHJ5Iiwid2F0Y2hlZEF0IiwidW5zaGlmdCIsImxlbmd0aCIsInNsaWNlIiwicmF0ZUFuaW1lIiwicmF0aW5nIiwiciIsInJhdGluZ0VudHJ5IiwicmF0ZWRBdCIsImdldFVzZXJSYXRpbmciLCJmaW5kIiwiZmluZFVzZXJCeUVtYWlsIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/userStorage.ts\n"));

/***/ })

});